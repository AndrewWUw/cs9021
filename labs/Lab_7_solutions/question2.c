/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Description: Prompts the user for an expression to be entered over one line *
 *              (ended by the ﬁrst ’\n’ character), checks whether it can be   *
 *              generated by the grammar below, and in case the answer is yes, *
 *              evaluates the expression and displays its value.               *
 *              Proceeds as long as the user does not input an empty line.     *
 *              The grammar:                                                   *
 *                  EXPRESSION --> TERM SUM_OPERATOR EXPRESSION                *
 *                  EXPRESSION --> TERM                                        *
 *                  TERM --> FACTOR MULT_OPERATOR TERM                         *
 *                  TERM --> FACTOR                                            *
 *                  FACTOR --> NUMBER                                          *
 *                  FACTOR --> (EXPRESSION)                                    *
 *                  NUMBER --> DIGIT NUMBER | NUMBER --> DIGIT                 *
 *                  DIGIT --> 0 | ... | 9                                      *
 *                  SUM_OPERATOR --> + | -                                     *
 *                  MULT_OPERATOR --> * | /                                    *
 *                                                                             *
 *  Written by Eric Martin for COMP9021                                        *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <ctype.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

bool is_expression(int *const );
bool is_term(int *const );
bool is_factor(int *const);
int number(const char c);

int main(void) {
    while (true) {
        int c;
        printf("Enter an expression: ");
        while ((c = getchar()) == ' ' || c == '\t')
            ;
        if (c == '\n') {
            printf("Bye\n");
            break;
        }
        ungetc(c, stdin);
        int expression;
        if (!is_expression(&expression)) {
            printf("Syntax is incorrect\n");
            /* Flush out remaining characters in buffer
             * before processing next expression. */
            while (getchar() != '\n')
                ;
            continue;
        }
        while ((c = getchar()) == ' ' || c == '\t')
            ;
        if (c == '\n') {
            printf("Syntax is correct\n");
            printf("Value is %d\n", expression);
        }
        else
            printf("Syntax is incorrect\n");
    }
    return EXIT_SUCCESS;
}

/* Checks that sequence of characters be to read
 * is a syntactically correct expression. If it is,
 * stores its value at location given by its argument. */
bool is_expression(int *const pt_to_expression) {
    int term;
    if (!is_term(&term))
        return false;
    int c;
    while ((c = getchar()) == ' ' || c == '\t')
        ;
    if (c == '+') {
        int expression;
        if (!is_expression(&expression))
            return false;
        *pt_to_expression = term + expression;
    }
    else if (c == '-') {
        int expression;
        if (!is_expression(&expression))
            return false;
        *pt_to_expression = term - expression;
    }
    else {
        *pt_to_expression = term;
        ungetc(c, stdin);
    }
    return true;
}

/* Checks that sequence of characters be to read
 * is a syntactically correct term. If it is,
 * stores its value at location given by its argument. */
bool is_term(int *const pt_to_term) {
    int factor;
    if (!is_factor(&factor))
        return false;
    int c;
    while ((c = getchar()) == ' ' || c == '\t')
        ;
    if (c == '*') {
        int term;
        if (!is_term(&term))
            return false;
        *pt_to_term = factor * term;
    }
    else if (c == '/') {
        int term;
        if (!is_term(&term) || term == 0)
            return false;
        *pt_to_term = factor / term;
    }
    else {
        *pt_to_term = factor;
        ungetc(c, stdin);
    }
    return true;
}

/* Checks that sequence of characters be to read
 * is a syntactically correct factor. If it is,
 * stores its value at location given by its argument. */
bool is_factor(int *const pt_to_factor) {
    int c;
    while ((c = getchar()) == ' ' || c == '\t')
        ;
    if (isdigit(c)) {
        *pt_to_factor = number(c);
        return true;
    }
    if (c == '(') {
        int expression;
        if (!is_expression(&expression))
            return false;
        while ((c = getchar()) == ' ' || c == '\t')
            ;
        if (c == ')') {
            *pt_to_factor = expression;
            return true;
        }
    }
    return false;
}

/* Called when c is the code of a digit.
 * Reads all following characters that are codes of digits.
 * Outputs the number made up of those digits. */
int number(const char c) {
    int result = c - '0';
    int next_c;
    while (isdigit(next_c = getchar()))
        result = 10 * result + next_c - '0';
    ungetc(next_c, stdin);
    return result;
}
